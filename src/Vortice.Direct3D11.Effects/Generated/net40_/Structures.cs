// <auto-generated/>

namespace SharpDX.Direct3D11
{
    /// <summary>
    /// <p>Describes an effect.</p>
    /// </summary>
    /// <remarks>
    /// <p><see cref = "SharpDX.Direct3D11.EffectDescription"/> is used with <strong>ID3DX11Effect::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476303</doc-id>
    /// <unmanaged>D3DX11_EFFECT_DESC</unmanaged>
    /// <unmanaged-short>D3DX11_EFFECT_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct EffectDescription
    {
        /// <summary>
        /// <dd> <p>Number of constant buffers in this effect.</p> </dd>
        /// </summary>
        /// <doc-id>ff476303</doc-id>
        /// <unmanaged>ConstantBuffers</unmanaged>
        /// <unmanaged-short>ConstantBuffers</unmanaged-short>
        public System.Int32 ConstantBufferCount;
        /// <summary>
        /// <dd> <p>Number of global variables in this effect.</p> </dd>
        /// </summary>
        /// <doc-id>ff476303</doc-id>
        /// <unmanaged>GlobalVariables</unmanaged>
        /// <unmanaged-short>GlobalVariables</unmanaged-short>
        public System.Int32 GlobalVariableCount;
        /// <summary>
        /// <dd> <p>Number of global interfaces in this effect.</p> </dd>
        /// </summary>
        /// <doc-id>ff476303</doc-id>
        /// <unmanaged>InterfaceVariables</unmanaged>
        /// <unmanaged-short>InterfaceVariables</unmanaged-short>
        public System.Int32 InterfaceVariableCount;
        /// <summary>
        /// <dd> <p>Number of techniques in this effect.</p> </dd>
        /// </summary>
        /// <doc-id>ff476303</doc-id>
        /// <unmanaged>Techniques</unmanaged>
        /// <unmanaged-short>Techniques</unmanaged-short>
        public System.Int32 TechniqueCount;
        /// <summary>
        /// <dd> <p>Number of groups in this effect.</p> </dd>
        /// </summary>
        /// <doc-id>ff476303</doc-id>
        /// <unmanaged>Groups</unmanaged>
        /// <unmanaged-short>Groups</unmanaged-short>
        public System.Int32 GroupCount;
    }

    /// <summary>
    /// <p>Describes an effect group.</p>
    /// </summary>
    /// <remarks>
    /// <p><see cref = "SharpDX.Direct3D11.EffectGroupDescription"/> is used with <strong>ID3DX11EffectTechnique::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476314</doc-id>
    /// <unmanaged>D3DX11_GROUP_DESC</unmanaged>
    /// <unmanaged-short>D3DX11_GROUP_DESC</unmanaged-short>
    public partial struct EffectGroupDescription
    {
        /// <summary>
        /// <dd> <p>Name of this group (only <strong><c>null</c></strong> if global).</p> </dd>
        /// </summary>
        /// <doc-id>ff476314</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// <dd> <p>Number of techniques contained in group.</p> </dd>
        /// </summary>
        /// <doc-id>ff476314</doc-id>
        /// <unmanaged>Techniques</unmanaged>
        /// <unmanaged-short>Techniques</unmanaged-short>
        public System.Int32 Techniques;
        /// <summary>
        /// <dd> <p>Number of annotations on this group.</p> </dd>
        /// </summary>
        /// <doc-id>ff476314</doc-id>
        /// <unmanaged>Annotations</unmanaged>
        /// <unmanaged-short>Annotations</unmanaged-short>
        public System.Int32 Annotations;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public System.Int32 Techniques;
            public System.Int32 Annotations;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
            Techniques = @ref.Techniques;
            Annotations = @ref.Annotations;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
            @ref.Techniques = Techniques;
            @ref.Annotations = Annotations;
        }
    }

    /// <summary>
    /// <p>Describes an effect pass, which contains pipeline state.</p>
    /// </summary>
    /// <remarks>
    /// <p><see cref = "SharpDX.Direct3D11.EffectPassDescription"/> is used with <strong>ID3DX11EffectPass::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476319</doc-id>
    /// <unmanaged>D3DX11_PASS_DESC</unmanaged>
    /// <unmanaged-short>D3DX11_PASS_DESC</unmanaged-short>
    public partial struct EffectPassDescription
    {
        /// <summary>
        /// <dd> <p>Name of this pass (<strong><c>null</c></strong> if not anonymous).</p> </dd>
        /// </summary>
        /// <doc-id>ff476319</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// <dd> <p>Number of annotations on this pass.</p> </dd>
        /// </summary>
        /// <doc-id>ff476319</doc-id>
        /// <unmanaged>Annotations</unmanaged>
        /// <unmanaged-short>Annotations</unmanaged-short>
        public System.Int32 AnnotationCount;
        /// <summary>
        /// <dd> <p>Signature from the vertex shader or geometry shader (if there is no vertex shader) or <strong><c>null</c></strong> if neither exists.</p> </dd>
        /// </summary>
        /// <doc-id>ff476319</doc-id>
        /// <unmanaged>pIAInputSignature</unmanaged>
        /// <unmanaged-short>pIAInputSignature</unmanaged-short>
        internal System.IntPtr PIAInputSignature;
        /// <summary>
        /// <dd> <p>Singature size in bytes.</p> </dd>
        /// </summary>
        /// <doc-id>ff476319</doc-id>
        /// <unmanaged>IAInputSignatureSize</unmanaged>
        /// <unmanaged-short>IAInputSignatureSize</unmanaged-short>
        internal System.Int32 IAInputSignatureSize;
        /// <summary>
        /// <dd> <p>The stencil-reference value used in the depth-stencil state.</p> </dd>
        /// </summary>
        /// <doc-id>ff476319</doc-id>
        /// <unmanaged>StencilRef</unmanaged>
        /// <unmanaged-short>StencilRef</unmanaged-short>
        public System.Int32 StencilReference;
        /// <summary>
        /// <dd> <p>The sample mask for the blend state.</p> </dd>
        /// </summary>
        /// <doc-id>ff476319</doc-id>
        /// <unmanaged>SampleMask</unmanaged>
        /// <unmanaged-short>SampleMask</unmanaged-short>
        public System.Int32 SampleMask;
        /// <summary>
        /// <dd> <p>The per-component blend factors (RGBA) for the blend state.</p> </dd>
        /// </summary>
        /// <doc-id>ff476319</doc-id>
        /// <unmanaged>BlendFactor</unmanaged>
        /// <unmanaged-short>BlendFactor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 BlendFactor;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public System.Int32 AnnotationCount;
            public System.IntPtr PIAInputSignature;
            public System.Int32 IAInputSignatureSize;
            public System.Int32 StencilReference;
            public System.Int32 SampleMask;
            public SharpDX.Mathematics.Interop.RawColor4 BlendFactor;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
            AnnotationCount = @ref.AnnotationCount;
            PIAInputSignature = @ref.PIAInputSignature;
            IAInputSignatureSize = @ref.IAInputSignatureSize;
            StencilReference = @ref.StencilReference;
            SampleMask = @ref.SampleMask;
            BlendFactor = @ref.BlendFactor;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
            @ref.AnnotationCount = AnnotationCount;
            @ref.PIAInputSignature = PIAInputSignature;
            @ref.IAInputSignatureSize = IAInputSignatureSize;
            @ref.StencilReference = StencilReference;
            @ref.SampleMask = SampleMask;
            @ref.BlendFactor = BlendFactor;
        }
    }

    /// <summary>
    /// <p>Describes an effect pass.</p>
    /// </summary>
    /// <remarks>
    /// <p><see cref = "SharpDX.Direct3D11.EffectPassShaderDescription"/> is used with <strong><see cref = "SharpDX.Direct3D11.EffectPass"/></strong> Get*ShaderDesc methods.</p><p>If this is an inline shader assignment, the returned interface will be an anonymous shader variable, which is not retrievable any other way.   It's name in the variable description will be "$Anonymous". If there is no assignment of this type in the pass block, pShaderVariable != <strong><c>null</c></strong>,  but pShaderVariable-&gt;IsValid() == <strong><see cref = "SharpDX.Result.False"/></strong>.</p>
    /// </remarks>
    /// <doc-id>ff476320</doc-id>
    /// <unmanaged>D3DX11_PASS_SHADER_DESC</unmanaged>
    /// <unmanaged-short>D3DX11_PASS_SHADER_DESC</unmanaged-short>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
    public partial struct EffectPassShaderDescription
    {
        /// <summary>
        /// <dd> <p>The variable that this shader came from.</p> </dd>
        /// </summary>
        /// <doc-id>ff476320</doc-id>
        /// <unmanaged>pShaderVariable</unmanaged>
        /// <unmanaged-short>pShaderVariable</unmanaged-short>
        internal System.IntPtr VariablePointer;
        /// <summary>
        /// <dd> <p>The element of pShaderVariable (if an array) or 0 if not applicable.</p> </dd>
        /// </summary>
        /// <doc-id>ff476320</doc-id>
        /// <unmanaged>ShaderIndex</unmanaged>
        /// <unmanaged-short>ShaderIndex</unmanaged-short>
        public System.Int32 Index;
    }

    /// <summary>
    /// <p>Describes an effect shader.</p>
    /// </summary>
    /// <remarks>
    /// <p><see cref = "SharpDX.Direct3D11.EffectShaderDescription"/> is used with <strong>ID3DX11EffectShaderVariable::GetShaderDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476304</doc-id>
    /// <unmanaged>D3DX11_EFFECT_SHADER_DESC</unmanaged>
    /// <unmanaged-short>D3DX11_EFFECT_SHADER_DESC</unmanaged-short>
    public partial struct EffectShaderDescription
    {
        /// <summary>
        /// <dd> <p>Passed into CreateInputLayout. Only valid on a vertex shader or geometry shader. See <strong>ID3D11Device::CreateInputLayout</strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476304</doc-id>
        /// <unmanaged>pInputSignature</unmanaged>
        /// <unmanaged-short>pInputSignature</unmanaged-short>
        internal System.IntPtr InputSignaturePointer;
        /// <summary>
        /// <dd> <p><strong>TRUE</strong> is the shader is defined inline; otherwise <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd>
        /// </summary>
        /// <doc-id>ff476304</doc-id>
        /// <unmanaged>IsInline</unmanaged>
        /// <unmanaged-short>IsInline</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsInline;
        /// <summary>
        /// <dd> <p>Shader bytecode.</p> </dd>
        /// </summary>
        /// <doc-id>ff476304</doc-id>
        /// <unmanaged>pBytecode</unmanaged>
        /// <unmanaged-short>pBytecode</unmanaged-short>
        internal System.IntPtr BytecodePointer;
        /// <summary>
        /// <dd> <p>The length of pBytecode. </p> </dd>
        /// </summary>
        /// <doc-id>ff476304</doc-id>
        /// <unmanaged>BytecodeLength</unmanaged>
        /// <unmanaged-short>BytecodeLength</unmanaged-short>
        internal System.Int32 BytecodeLength;
        /// <summary>
        /// <dd> <p>Stream out declaration string (for geometry shader with SO).</p> </dd>
        /// </summary>
        /// <doc-id>ff476304</doc-id>
        /// <unmanaged>SODecls</unmanaged>
        /// <unmanaged-short>SODecls</unmanaged-short>
        internal System.IntPtr[] SODecls
        {
            get => _SODecls ?? (_SODecls = new System.IntPtr[4]);
            private set => _SODecls = value;
        }

        internal System.IntPtr[] _SODecls;
        /// <summary>
        /// <dd> <p>Indicates which stream is rasterized.  D3D11 geometry shaders can output up to four streams of data, one of which can be rasterized.</p> </dd>
        /// </summary>
        /// <doc-id>ff476304</doc-id>
        /// <unmanaged>RasterizedStream</unmanaged>
        /// <unmanaged-short>RasterizedStream</unmanaged-short>
        public System.Int32 RasterizedStream;
        /// <summary>
        /// <dd> <p>Number of entries in the input signature.</p> </dd>
        /// </summary>
        /// <doc-id>ff476304</doc-id>
        /// <unmanaged>NumInputSignatureEntries</unmanaged>
        /// <unmanaged-short>NumInputSignatureEntries</unmanaged-short>
        public System.Int32 InputParameterCount;
        /// <summary>
        /// <dd> <p>Number of entries in the output signature.</p> </dd>
        /// </summary>
        /// <doc-id>ff476304</doc-id>
        /// <unmanaged>NumOutputSignatureEntries</unmanaged>
        /// <unmanaged-short>NumOutputSignatureEntries</unmanaged-short>
        public System.Int32 OutputParameterCount;
        /// <summary>
        /// <dd> <p>Number of entries in the patch constant signature.</p> </dd>
        /// </summary>
        /// <doc-id>ff476304</doc-id>
        /// <unmanaged>NumPatchConstantSignatureEntries</unmanaged>
        /// <unmanaged-short>NumPatchConstantSignatureEntries</unmanaged-short>
        public System.Int32 PatchConstantSignatureEntrieCount;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr InputSignaturePointer;
            public SharpDX.Mathematics.Interop.RawBool IsInline;
            public System.IntPtr BytecodePointer;
            public System.Int32 BytecodeLength;
            public System.IntPtr SODecls;
            public System.IntPtr __SODecls1;
            public System.IntPtr __SODecls2;
            public System.IntPtr __SODecls3;
            public System.Int32 RasterizedStream;
            public System.Int32 InputParameterCount;
            public System.Int32 OutputParameterCount;
            public System.Int32 PatchConstantSignatureEntrieCount;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            InputSignaturePointer = @ref.InputSignaturePointer;
            IsInline = @ref.IsInline;
            BytecodePointer = @ref.BytecodePointer;
            BytecodeLength = @ref.BytecodeLength;
            fixed (void *__to = &SODecls[0], __from = &@ref.SODecls)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.IntPtr));
            RasterizedStream = @ref.RasterizedStream;
            InputParameterCount = @ref.InputParameterCount;
            OutputParameterCount = @ref.OutputParameterCount;
            PatchConstantSignatureEntrieCount = @ref.PatchConstantSignatureEntrieCount;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.InputSignaturePointer = InputSignaturePointer;
            @ref.IsInline = IsInline;
            @ref.BytecodePointer = BytecodePointer;
            @ref.BytecodeLength = BytecodeLength;
            fixed (void *__from = &SODecls[0], __to = &@ref.SODecls)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.IntPtr));
            @ref.RasterizedStream = RasterizedStream;
            @ref.InputParameterCount = InputParameterCount;
            @ref.OutputParameterCount = OutputParameterCount;
            @ref.PatchConstantSignatureEntrieCount = PatchConstantSignatureEntrieCount;
        }
    }

    /// <summary>
    /// <p>Describes an effect technique.</p>
    /// </summary>
    /// <remarks>
    /// <p><see cref = "SharpDX.Direct3D11.EffectTechniqueDescription"/> is used with <strong>ID3DX11EffectTechnique::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476326</doc-id>
    /// <unmanaged>D3DX11_TECHNIQUE_DESC</unmanaged>
    /// <unmanaged-short>D3DX11_TECHNIQUE_DESC</unmanaged-short>
    public partial struct EffectTechniqueDescription
    {
        /// <summary>
        /// <dd> <p>Name of this technique (<c>null</c> if not anonymous).</p> </dd>
        /// </summary>
        /// <doc-id>ff476326</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// <dd> <p>Number of passes contained in the technique.</p> </dd>
        /// </summary>
        /// <doc-id>ff476326</doc-id>
        /// <unmanaged>Passes</unmanaged>
        /// <unmanaged-short>Passes</unmanaged-short>
        public System.Int32 PassCount;
        /// <summary>
        /// <dd> <p>Number of annotations on this technique.</p> </dd>
        /// </summary>
        /// <doc-id>ff476326</doc-id>
        /// <unmanaged>Annotations</unmanaged>
        /// <unmanaged-short>Annotations</unmanaged-short>
        public System.Int32 AnnotationCount;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public System.Int32 PassCount;
            public System.Int32 AnnotationCount;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
            PassCount = @ref.PassCount;
            AnnotationCount = @ref.AnnotationCount;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
            @ref.PassCount = PassCount;
            @ref.AnnotationCount = AnnotationCount;
        }
    }

    /// <summary>
    /// <p>Describes an effect-variable type.</p>
    /// </summary>
    /// <remarks>
    /// <p><see cref = "SharpDX.Direct3D11.EffectTypeDescription"/> is used with <strong>ID3DX11EffectType::GetDesc</strong> </p>
    /// </remarks>
    /// <doc-id>ff476305</doc-id>
    /// <unmanaged>D3DX11_EFFECT_TYPE_DESC</unmanaged>
    /// <unmanaged-short>D3DX11_EFFECT_TYPE_DESC</unmanaged-short>
    public partial struct EffectTypeDescription
    {
        /// <summary>
        /// <dd> <p>Name of the type, for example "float4" or "MyStruct".</p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>TypeName</unmanaged>
        /// <unmanaged-short>TypeName</unmanaged-short>
        public System.String TypeName;
        /// <summary>
        /// <dd> <p>The variable class (see <strong>D3D10_SHADER_VARIABLE_CLASS</strong>). </p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>Class</unmanaged>
        /// <unmanaged-short>Class</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderVariableClass Class;
        /// <summary>
        /// <dd> <p>The variable type (see <strong>D3D10_SHADER_VARIABLE_TYPE</strong>).</p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>Type</unmanaged>
        /// <unmanaged-short>Type</unmanaged-short>
        public SharpDX.D3DCompiler.ShaderVariableType Type;
        /// <summary>
        /// <dd> <p>Number of elements in this type (0 if not an array).</p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>Elements</unmanaged>
        /// <unmanaged-short>Elements</unmanaged-short>
        public System.Int32 Elements;
        /// <summary>
        /// <dd> <p>Number of members (0 if not a structure).</p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>Members</unmanaged>
        /// <unmanaged-short>Members</unmanaged-short>
        public System.Int32 Members;
        /// <summary>
        /// <dd> <p>Number of rows in this type (0 if not a numeric primitive).</p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>Rows</unmanaged>
        /// <unmanaged-short>Rows</unmanaged-short>
        public System.Int32 Rows;
        /// <summary>
        /// <dd> <p>Number of columns in this type (0 if not a numeric primitive).</p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>Columns</unmanaged>
        /// <unmanaged-short>Columns</unmanaged-short>
        public System.Int32 Columns;
        /// <summary>
        /// <dd> <p>Number of bytes required to represent this data type, when tightly packed.</p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>PackedSize</unmanaged>
        /// <unmanaged-short>PackedSize</unmanaged-short>
        public System.Int32 PackedSize;
        /// <summary>
        /// <dd> <p>Number of bytes occupied by this data type, when laid out in a constant buffer.</p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>UnpackedSize</unmanaged>
        /// <unmanaged-short>UnpackedSize</unmanaged-short>
        public System.Int32 UnpackedSize;
        /// <summary>
        /// <dd> <p>Number of bytes to seek between elements, when laid out in a constant buffer.</p> </dd>
        /// </summary>
        /// <doc-id>ff476305</doc-id>
        /// <unmanaged>Stride</unmanaged>
        /// <unmanaged-short>Stride</unmanaged-short>
        public System.Int32 Stride;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr TypeName;
            public SharpDX.D3DCompiler.ShaderVariableClass Class;
            public SharpDX.D3DCompiler.ShaderVariableType Type;
            public System.Int32 Elements;
            public System.Int32 Members;
            public System.Int32 Rows;
            public System.Int32 Columns;
            public System.Int32 PackedSize;
            public System.Int32 UnpackedSize;
            public System.Int32 Stride;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.TypeName);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            TypeName = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.TypeName);
            Class = @ref.Class;
            Type = @ref.Type;
            Elements = @ref.Elements;
            Members = @ref.Members;
            Rows = @ref.Rows;
            Columns = @ref.Columns;
            PackedSize = @ref.PackedSize;
            UnpackedSize = @ref.UnpackedSize;
            Stride = @ref.Stride;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.TypeName = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(TypeName);
            @ref.Class = Class;
            @ref.Type = Type;
            @ref.Elements = Elements;
            @ref.Members = Members;
            @ref.Rows = Rows;
            @ref.Columns = Columns;
            @ref.PackedSize = PackedSize;
            @ref.UnpackedSize = UnpackedSize;
            @ref.Stride = Stride;
        }
    }

    /// <summary>
    /// <p>Describes an effect variable.</p>
    /// </summary>
    /// <remarks>
    /// <p><see cref = "SharpDX.Direct3D11.EffectVariableDescription"/> is used with <strong>ID3DX11EffectVariable::GetDesc</strong>.</p>
    /// </remarks>
    /// <doc-id>ff476306</doc-id>
    /// <unmanaged>D3DX11_EFFECT_VARIABLE_DESC</unmanaged>
    /// <unmanaged-short>D3DX11_EFFECT_VARIABLE_DESC</unmanaged-short>
    public partial struct EffectVariableDescription
    {
        /// <summary>
        /// <dd> <p>Name of this variable, annotation, or structure member.</p> </dd>
        /// </summary>
        /// <doc-id>ff476306</doc-id>
        /// <unmanaged>Name</unmanaged>
        /// <unmanaged-short>Name</unmanaged-short>
        public System.String Name;
        /// <summary>
        /// <dd> <p>Semantic string of this variable or structure member (<c>null</c> for annotations or if not present).</p> </dd>
        /// </summary>
        /// <doc-id>ff476306</doc-id>
        /// <unmanaged>Semantic</unmanaged>
        /// <unmanaged-short>Semantic</unmanaged-short>
        public System.String Semantic;
        /// <summary>
        /// <dd> <p>Optional flags for effect variables.</p> </dd>
        /// </summary>
        /// <doc-id>ff476306</doc-id>
        /// <unmanaged>Flags</unmanaged>
        /// <unmanaged-short>Flags</unmanaged-short>
        public SharpDX.Direct3D11.EffectVariableFlags Flags;
        /// <summary>
        /// <dd> <p>Number of annotations on this variable (always 0 for annotations).</p> </dd>
        /// </summary>
        /// <doc-id>ff476306</doc-id>
        /// <unmanaged>Annotations</unmanaged>
        /// <unmanaged-short>Annotations</unmanaged-short>
        public System.Int32 AnnotationCount;
        /// <summary>
        /// <dd> <p>Offset into containing cbuffer or tbuffer (always 0 for annotations or variables not in constant buffers).</p> </dd>
        /// </summary>
        /// <doc-id>ff476306</doc-id>
        /// <unmanaged>BufferOffset</unmanaged>
        /// <unmanaged-short>BufferOffset</unmanaged-short>
        public System.Int32 BufferOffset;
        /// <summary>
        /// <dd> <p>Used if the variable has been explicitly bound using the register keyword. Check Flags for D3DX11_EFFECT_VARIABLE_EXPLICIT_BIND_POINT.</p> </dd>
        /// </summary>
        /// <doc-id>ff476306</doc-id>
        /// <unmanaged>ExplicitBindPoint</unmanaged>
        /// <unmanaged-short>ExplicitBindPoint</unmanaged-short>
        public System.Int32 ExplicitBindPoint;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.IntPtr Name;
            public System.IntPtr Semantic;
            public SharpDX.Direct3D11.EffectVariableFlags Flags;
            public System.Int32 AnnotationCount;
            public System.Int32 BufferOffset;
            public System.Int32 ExplicitBindPoint;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Name);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(@ref.Semantic);
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            Name = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Name);
            Semantic = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(@ref.Semantic);
            Flags = @ref.Flags;
            AnnotationCount = @ref.AnnotationCount;
            BufferOffset = @ref.BufferOffset;
            ExplicitBindPoint = @ref.ExplicitBindPoint;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Name);
            @ref.Semantic = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(Semantic);
            @ref.Flags = Flags;
            @ref.AnnotationCount = AnnotationCount;
            @ref.BufferOffset = BufferOffset;
            @ref.ExplicitBindPoint = ExplicitBindPoint;
        }
    }

    /// <summary>
    /// <p>Indicates the device state.</p>
    /// </summary>
    /// <remarks>
    /// <p>A state-block mask indicates the device states that a pass or a technique changes.</p>
    /// </remarks>
    /// <doc-id>ff476325</doc-id>
    /// <unmanaged>D3DX11_STATE_BLOCK_MASK</unmanaged>
    /// <unmanaged-short>D3DX11_STATE_BLOCK_MASK</unmanaged-short>
    public partial struct StateBlockMask
    {
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the vertex shader state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>VS</unmanaged>
        /// <unmanaged-short>VS</unmanaged-short>
        public System.Byte VertexShader;
        /// <summary>
        /// <dd> <p>Array of vertex-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>VSSamplers</unmanaged>
        /// <unmanaged-short>VSSamplers</unmanaged-short>
        public System.Byte[] VSSamplers
        {
            get => _VSSamplers ?? (_VSSamplers = new System.Byte[2]);
            private set => _VSSamplers = value;
        }

        internal System.Byte[] _VSSamplers;
        /// <summary>
        /// <dd> <p>Array of vertex-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>VSShaderResources</unmanaged>
        /// <unmanaged-short>VSShaderResources</unmanaged-short>
        public System.Byte[] VSShaderResources
        {
            get => _VSShaderResources ?? (_VSShaderResources = new System.Byte[16]);
            private set => _VSShaderResources = value;
        }

        internal System.Byte[] _VSShaderResources;
        /// <summary>
        /// <dd> <p>Array of vertex-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>VSConstantBuffers</unmanaged>
        /// <unmanaged-short>VSConstantBuffers</unmanaged-short>
        public System.Byte[] VSConstantBuffers
        {
            get => _VSConstantBuffers ?? (_VSConstantBuffers = new System.Byte[2]);
            private set => _VSConstantBuffers = value;
        }

        internal System.Byte[] _VSConstantBuffers;
        /// <summary>
        /// <dd> <p>Array of vertex-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>VSInterfaces</unmanaged>
        /// <unmanaged-short>VSInterfaces</unmanaged-short>
        public System.Byte[] VSInterfaces
        {
            get => _VSInterfaces ?? (_VSInterfaces = new System.Byte[32]);
            private set => _VSInterfaces = value;
        }

        internal System.Byte[] _VSInterfaces;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the hull shader state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>HS</unmanaged>
        /// <unmanaged-short>HS</unmanaged-short>
        public System.Byte HullShader;
        /// <summary>
        /// <dd> <p>Array of hull-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>HSSamplers</unmanaged>
        /// <unmanaged-short>HSSamplers</unmanaged-short>
        public System.Byte[] HSSamplers
        {
            get => _HSSamplers ?? (_HSSamplers = new System.Byte[2]);
            private set => _HSSamplers = value;
        }

        internal System.Byte[] _HSSamplers;
        /// <summary>
        /// <dd> <p>Array of hull-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>HSShaderResources</unmanaged>
        /// <unmanaged-short>HSShaderResources</unmanaged-short>
        public System.Byte[] HSShaderResources
        {
            get => _HSShaderResources ?? (_HSShaderResources = new System.Byte[16]);
            private set => _HSShaderResources = value;
        }

        internal System.Byte[] _HSShaderResources;
        /// <summary>
        /// <dd> <p>Array of hull-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>HSConstantBuffers</unmanaged>
        /// <unmanaged-short>HSConstantBuffers</unmanaged-short>
        public System.Byte[] HSConstantBuffers
        {
            get => _HSConstantBuffers ?? (_HSConstantBuffers = new System.Byte[2]);
            private set => _HSConstantBuffers = value;
        }

        internal System.Byte[] _HSConstantBuffers;
        /// <summary>
        /// <dd> <p>Array of hull-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>HSInterfaces</unmanaged>
        /// <unmanaged-short>HSInterfaces</unmanaged-short>
        public System.Byte[] HSInterfaces
        {
            get => _HSInterfaces ?? (_HSInterfaces = new System.Byte[32]);
            private set => _HSInterfaces = value;
        }

        internal System.Byte[] _HSInterfaces;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the domain shader state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>DS</unmanaged>
        /// <unmanaged-short>DS</unmanaged-short>
        public System.Byte DomainShader;
        /// <summary>
        /// <dd> <p>Array of domain-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>DSSamplers</unmanaged>
        /// <unmanaged-short>DSSamplers</unmanaged-short>
        public System.Byte[] DSSamplers
        {
            get => _DSSamplers ?? (_DSSamplers = new System.Byte[2]);
            private set => _DSSamplers = value;
        }

        internal System.Byte[] _DSSamplers;
        /// <summary>
        /// <dd> <p>Array of domain-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>DSShaderResources</unmanaged>
        /// <unmanaged-short>DSShaderResources</unmanaged-short>
        public System.Byte[] DSShaderResources
        {
            get => _DSShaderResources ?? (_DSShaderResources = new System.Byte[16]);
            private set => _DSShaderResources = value;
        }

        internal System.Byte[] _DSShaderResources;
        /// <summary>
        /// <dd> <p>Array of domain-shader constant buffers. The array is a multi-byte bitmask where each bit represents one buffer slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>DSConstantBuffers</unmanaged>
        /// <unmanaged-short>DSConstantBuffers</unmanaged-short>
        public System.Byte[] DSConstantBuffers
        {
            get => _DSConstantBuffers ?? (_DSConstantBuffers = new System.Byte[2]);
            private set => _DSConstantBuffers = value;
        }

        internal System.Byte[] _DSConstantBuffers;
        /// <summary>
        /// <dd> <p>Array of domain-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>DSInterfaces</unmanaged>
        /// <unmanaged-short>DSInterfaces</unmanaged-short>
        public System.Byte[] DSInterfaces
        {
            get => _DSInterfaces ?? (_DSInterfaces = new System.Byte[32]);
            private set => _DSInterfaces = value;
        }

        internal System.Byte[] _DSInterfaces;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the geometry shader state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>GS</unmanaged>
        /// <unmanaged-short>GS</unmanaged-short>
        public System.Byte GeometryShader;
        /// <summary>
        /// <dd> <p>Array of geometry-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>GSSamplers</unmanaged>
        /// <unmanaged-short>GSSamplers</unmanaged-short>
        public System.Byte[] GSSamplers
        {
            get => _GSSamplers ?? (_GSSamplers = new System.Byte[2]);
            private set => _GSSamplers = value;
        }

        internal System.Byte[] _GSSamplers;
        /// <summary>
        /// <dd> <p>Array of geometry-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>GSShaderResources</unmanaged>
        /// <unmanaged-short>GSShaderResources</unmanaged-short>
        public System.Byte[] GSShaderResources
        {
            get => _GSShaderResources ?? (_GSShaderResources = new System.Byte[16]);
            private set => _GSShaderResources = value;
        }

        internal System.Byte[] _GSShaderResources;
        /// <summary>
        /// <dd> <p>Array of geometry-shader constant buffers. The array is a multi-byte bitmask where each bit represents one buffer slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>GSConstantBuffers</unmanaged>
        /// <unmanaged-short>GSConstantBuffers</unmanaged-short>
        public System.Byte[] GSConstantBuffers
        {
            get => _GSConstantBuffers ?? (_GSConstantBuffers = new System.Byte[2]);
            private set => _GSConstantBuffers = value;
        }

        internal System.Byte[] _GSConstantBuffers;
        /// <summary>
        /// <dd> <p>Array of geometry-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>GSInterfaces</unmanaged>
        /// <unmanaged-short>GSInterfaces</unmanaged-short>
        public System.Byte[] GSInterfaces
        {
            get => _GSInterfaces ?? (_GSInterfaces = new System.Byte[32]);
            private set => _GSInterfaces = value;
        }

        internal System.Byte[] _GSInterfaces;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the pixel shader state.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>PS</unmanaged>
        /// <unmanaged-short>PS</unmanaged-short>
        public System.Byte PixelShader;
        /// <summary>
        /// <dd> <p>Array of pixel-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>PSSamplers</unmanaged>
        /// <unmanaged-short>PSSamplers</unmanaged-short>
        public System.Byte[] PSSamplers
        {
            get => _PSSamplers ?? (_PSSamplers = new System.Byte[2]);
            private set => _PSSamplers = value;
        }

        internal System.Byte[] _PSSamplers;
        /// <summary>
        /// <dd> <p>Array of pixel-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>PSShaderResources</unmanaged>
        /// <unmanaged-short>PSShaderResources</unmanaged-short>
        public System.Byte[] PSShaderResources
        {
            get => _PSShaderResources ?? (_PSShaderResources = new System.Byte[16]);
            private set => _PSShaderResources = value;
        }

        internal System.Byte[] _PSShaderResources;
        /// <summary>
        /// <dd> <p>Array of pixel-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>PSConstantBuffers</unmanaged>
        /// <unmanaged-short>PSConstantBuffers</unmanaged-short>
        public System.Byte[] PSConstantBuffers
        {
            get => _PSConstantBuffers ?? (_PSConstantBuffers = new System.Byte[2]);
            private set => _PSConstantBuffers = value;
        }

        internal System.Byte[] _PSConstantBuffers;
        /// <summary>
        /// <dd> <p>Array of pixel-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>PSInterfaces</unmanaged>
        /// <unmanaged-short>PSInterfaces</unmanaged-short>
        public System.Byte[] PSInterfaces
        {
            get => _PSInterfaces ?? (_PSInterfaces = new System.Byte[32]);
            private set => _PSInterfaces = value;
        }

        internal System.Byte[] _PSInterfaces;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the pixel shader unordered access views.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>PSUnorderedAccessViews</unmanaged>
        /// <unmanaged-short>PSUnorderedAccessViews</unmanaged-short>
        public System.Byte PSUnorderedAccessViews;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the compute shader state.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>CS</unmanaged>
        /// <unmanaged-short>CS</unmanaged-short>
        public System.Byte ComputeShader;
        /// <summary>
        /// <dd> <p>Array of compute-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>CSSamplers</unmanaged>
        /// <unmanaged-short>CSSamplers</unmanaged-short>
        public System.Byte[] CSSamplers
        {
            get => _CSSamplers ?? (_CSSamplers = new System.Byte[2]);
            private set => _CSSamplers = value;
        }

        internal System.Byte[] _CSSamplers;
        /// <summary>
        /// <dd> <p>Array of compute-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>CSShaderResources</unmanaged>
        /// <unmanaged-short>CSShaderResources</unmanaged-short>
        public System.Byte[] CSShaderResources
        {
            get => _CSShaderResources ?? (_CSShaderResources = new System.Byte[16]);
            private set => _CSShaderResources = value;
        }

        internal System.Byte[] _CSShaderResources;
        /// <summary>
        /// <dd> <p>Array of compute-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>CSConstantBuffers</unmanaged>
        /// <unmanaged-short>CSConstantBuffers</unmanaged-short>
        public System.Byte[] CSConstantBuffers
        {
            get => _CSConstantBuffers ?? (_CSConstantBuffers = new System.Byte[2]);
            private set => _CSConstantBuffers = value;
        }

        internal System.Byte[] _CSConstantBuffers;
        /// <summary>
        /// <dd> <p>Array of compute-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>CSInterfaces</unmanaged>
        /// <unmanaged-short>CSInterfaces</unmanaged-short>
        public System.Byte[] CSInterfaces
        {
            get => _CSInterfaces ?? (_CSInterfaces = new System.Byte[32]);
            private set => _CSInterfaces = value;
        }

        internal System.Byte[] _CSInterfaces;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the compute shader unordered access views.</p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>CSUnorderedAccessViews</unmanaged>
        /// <unmanaged-short>CSUnorderedAccessViews</unmanaged-short>
        public System.Byte CSUnorderedAccessViews;
        /// <summary>
        /// <dd> <p>Array of vertex buffers. The array is a multi-byte bitmask where each bit represents one resource slot. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>IAVertexBuffers</unmanaged>
        /// <unmanaged-short>IAVertexBuffers</unmanaged-short>
        public System.Byte[] IAVertexBuffers
        {
            get => _IAVertexBuffers ?? (_IAVertexBuffers = new System.Byte[4]);
            private set => _IAVertexBuffers = value;
        }

        internal System.Byte[] _IAVertexBuffers;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the index buffer state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>IAIndexBuffer</unmanaged>
        /// <unmanaged-short>IAIndexBuffer</unmanaged-short>
        public System.Byte IAIndexBuffer;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the input layout state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>IAInputLayout</unmanaged>
        /// <unmanaged-short>IAInputLayout</unmanaged-short>
        public System.Byte IAInputLayout;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the primitive topology state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>IAPrimitiveTopology</unmanaged>
        /// <unmanaged-short>IAPrimitiveTopology</unmanaged-short>
        public System.Byte IAPrimitiveTopology;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the render targets states. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>OMRenderTargets</unmanaged>
        /// <unmanaged-short>OMRenderTargets</unmanaged-short>
        public System.Byte OMRenderTargets;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the depth-stencil state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>OMDepthStencilState</unmanaged>
        /// <unmanaged-short>OMDepthStencilState</unmanaged-short>
        public System.Byte OMDepthStencilState;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the blend state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>OMBlendState</unmanaged>
        /// <unmanaged-short>OMBlendState</unmanaged-short>
        public System.Byte OMBlendState;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the viewports states. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>RSViewports</unmanaged>
        /// <unmanaged-short>RSViewports</unmanaged-short>
        public System.Byte RSViewports;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the scissor rectangles states. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>RSScissorRects</unmanaged>
        /// <unmanaged-short>RSScissorRects</unmanaged-short>
        public System.Byte RSScissorRects;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the rasterizer state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>RSRasterizerState</unmanaged>
        /// <unmanaged-short>RSRasterizerState</unmanaged-short>
        public System.Byte RSRasterizerState;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the stream-out buffers states. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>SOBuffers</unmanaged>
        /// <unmanaged-short>SOBuffers</unmanaged-short>
        public System.Byte SOBuffers;
        /// <summary>
        /// <dd> <p>Boolean value indicating whether to save the predication state. </p> </dd>
        /// </summary>
        /// <doc-id>ff476325</doc-id>
        /// <unmanaged>Predication</unmanaged>
        /// <unmanaged-short>Predication</unmanaged-short>
        public System.Byte Predication;
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 0, CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        internal partial struct __Native
        {
            public System.Byte VertexShader;
            public System.Byte VSSamplers;
            public System.Byte __VSSamplers1;
            public System.Byte VSShaderResources;
            public System.Byte __VSShaderResources1;
            public System.Byte __VSShaderResources2;
            public System.Byte __VSShaderResources3;
            public System.Byte __VSShaderResources4;
            public System.Byte __VSShaderResources5;
            public System.Byte __VSShaderResources6;
            public System.Byte __VSShaderResources7;
            public System.Byte __VSShaderResources8;
            public System.Byte __VSShaderResources9;
            public System.Byte __VSShaderResources10;
            public System.Byte __VSShaderResources11;
            public System.Byte __VSShaderResources12;
            public System.Byte __VSShaderResources13;
            public System.Byte __VSShaderResources14;
            public System.Byte __VSShaderResources15;
            public System.Byte VSConstantBuffers;
            public System.Byte __VSConstantBuffers1;
            public System.Byte VSInterfaces;
            public System.Byte __VSInterfaces1;
            public System.Byte __VSInterfaces2;
            public System.Byte __VSInterfaces3;
            public System.Byte __VSInterfaces4;
            public System.Byte __VSInterfaces5;
            public System.Byte __VSInterfaces6;
            public System.Byte __VSInterfaces7;
            public System.Byte __VSInterfaces8;
            public System.Byte __VSInterfaces9;
            public System.Byte __VSInterfaces10;
            public System.Byte __VSInterfaces11;
            public System.Byte __VSInterfaces12;
            public System.Byte __VSInterfaces13;
            public System.Byte __VSInterfaces14;
            public System.Byte __VSInterfaces15;
            public System.Byte __VSInterfaces16;
            public System.Byte __VSInterfaces17;
            public System.Byte __VSInterfaces18;
            public System.Byte __VSInterfaces19;
            public System.Byte __VSInterfaces20;
            public System.Byte __VSInterfaces21;
            public System.Byte __VSInterfaces22;
            public System.Byte __VSInterfaces23;
            public System.Byte __VSInterfaces24;
            public System.Byte __VSInterfaces25;
            public System.Byte __VSInterfaces26;
            public System.Byte __VSInterfaces27;
            public System.Byte __VSInterfaces28;
            public System.Byte __VSInterfaces29;
            public System.Byte __VSInterfaces30;
            public System.Byte __VSInterfaces31;
            public System.Byte HullShader;
            public System.Byte HSSamplers;
            public System.Byte __HSSamplers1;
            public System.Byte HSShaderResources;
            public System.Byte __HSShaderResources1;
            public System.Byte __HSShaderResources2;
            public System.Byte __HSShaderResources3;
            public System.Byte __HSShaderResources4;
            public System.Byte __HSShaderResources5;
            public System.Byte __HSShaderResources6;
            public System.Byte __HSShaderResources7;
            public System.Byte __HSShaderResources8;
            public System.Byte __HSShaderResources9;
            public System.Byte __HSShaderResources10;
            public System.Byte __HSShaderResources11;
            public System.Byte __HSShaderResources12;
            public System.Byte __HSShaderResources13;
            public System.Byte __HSShaderResources14;
            public System.Byte __HSShaderResources15;
            public System.Byte HSConstantBuffers;
            public System.Byte __HSConstantBuffers1;
            public System.Byte HSInterfaces;
            public System.Byte __HSInterfaces1;
            public System.Byte __HSInterfaces2;
            public System.Byte __HSInterfaces3;
            public System.Byte __HSInterfaces4;
            public System.Byte __HSInterfaces5;
            public System.Byte __HSInterfaces6;
            public System.Byte __HSInterfaces7;
            public System.Byte __HSInterfaces8;
            public System.Byte __HSInterfaces9;
            public System.Byte __HSInterfaces10;
            public System.Byte __HSInterfaces11;
            public System.Byte __HSInterfaces12;
            public System.Byte __HSInterfaces13;
            public System.Byte __HSInterfaces14;
            public System.Byte __HSInterfaces15;
            public System.Byte __HSInterfaces16;
            public System.Byte __HSInterfaces17;
            public System.Byte __HSInterfaces18;
            public System.Byte __HSInterfaces19;
            public System.Byte __HSInterfaces20;
            public System.Byte __HSInterfaces21;
            public System.Byte __HSInterfaces22;
            public System.Byte __HSInterfaces23;
            public System.Byte __HSInterfaces24;
            public System.Byte __HSInterfaces25;
            public System.Byte __HSInterfaces26;
            public System.Byte __HSInterfaces27;
            public System.Byte __HSInterfaces28;
            public System.Byte __HSInterfaces29;
            public System.Byte __HSInterfaces30;
            public System.Byte __HSInterfaces31;
            public System.Byte DomainShader;
            public System.Byte DSSamplers;
            public System.Byte __DSSamplers1;
            public System.Byte DSShaderResources;
            public System.Byte __DSShaderResources1;
            public System.Byte __DSShaderResources2;
            public System.Byte __DSShaderResources3;
            public System.Byte __DSShaderResources4;
            public System.Byte __DSShaderResources5;
            public System.Byte __DSShaderResources6;
            public System.Byte __DSShaderResources7;
            public System.Byte __DSShaderResources8;
            public System.Byte __DSShaderResources9;
            public System.Byte __DSShaderResources10;
            public System.Byte __DSShaderResources11;
            public System.Byte __DSShaderResources12;
            public System.Byte __DSShaderResources13;
            public System.Byte __DSShaderResources14;
            public System.Byte __DSShaderResources15;
            public System.Byte DSConstantBuffers;
            public System.Byte __DSConstantBuffers1;
            public System.Byte DSInterfaces;
            public System.Byte __DSInterfaces1;
            public System.Byte __DSInterfaces2;
            public System.Byte __DSInterfaces3;
            public System.Byte __DSInterfaces4;
            public System.Byte __DSInterfaces5;
            public System.Byte __DSInterfaces6;
            public System.Byte __DSInterfaces7;
            public System.Byte __DSInterfaces8;
            public System.Byte __DSInterfaces9;
            public System.Byte __DSInterfaces10;
            public System.Byte __DSInterfaces11;
            public System.Byte __DSInterfaces12;
            public System.Byte __DSInterfaces13;
            public System.Byte __DSInterfaces14;
            public System.Byte __DSInterfaces15;
            public System.Byte __DSInterfaces16;
            public System.Byte __DSInterfaces17;
            public System.Byte __DSInterfaces18;
            public System.Byte __DSInterfaces19;
            public System.Byte __DSInterfaces20;
            public System.Byte __DSInterfaces21;
            public System.Byte __DSInterfaces22;
            public System.Byte __DSInterfaces23;
            public System.Byte __DSInterfaces24;
            public System.Byte __DSInterfaces25;
            public System.Byte __DSInterfaces26;
            public System.Byte __DSInterfaces27;
            public System.Byte __DSInterfaces28;
            public System.Byte __DSInterfaces29;
            public System.Byte __DSInterfaces30;
            public System.Byte __DSInterfaces31;
            public System.Byte GeometryShader;
            public System.Byte GSSamplers;
            public System.Byte __GSSamplers1;
            public System.Byte GSShaderResources;
            public System.Byte __GSShaderResources1;
            public System.Byte __GSShaderResources2;
            public System.Byte __GSShaderResources3;
            public System.Byte __GSShaderResources4;
            public System.Byte __GSShaderResources5;
            public System.Byte __GSShaderResources6;
            public System.Byte __GSShaderResources7;
            public System.Byte __GSShaderResources8;
            public System.Byte __GSShaderResources9;
            public System.Byte __GSShaderResources10;
            public System.Byte __GSShaderResources11;
            public System.Byte __GSShaderResources12;
            public System.Byte __GSShaderResources13;
            public System.Byte __GSShaderResources14;
            public System.Byte __GSShaderResources15;
            public System.Byte GSConstantBuffers;
            public System.Byte __GSConstantBuffers1;
            public System.Byte GSInterfaces;
            public System.Byte __GSInterfaces1;
            public System.Byte __GSInterfaces2;
            public System.Byte __GSInterfaces3;
            public System.Byte __GSInterfaces4;
            public System.Byte __GSInterfaces5;
            public System.Byte __GSInterfaces6;
            public System.Byte __GSInterfaces7;
            public System.Byte __GSInterfaces8;
            public System.Byte __GSInterfaces9;
            public System.Byte __GSInterfaces10;
            public System.Byte __GSInterfaces11;
            public System.Byte __GSInterfaces12;
            public System.Byte __GSInterfaces13;
            public System.Byte __GSInterfaces14;
            public System.Byte __GSInterfaces15;
            public System.Byte __GSInterfaces16;
            public System.Byte __GSInterfaces17;
            public System.Byte __GSInterfaces18;
            public System.Byte __GSInterfaces19;
            public System.Byte __GSInterfaces20;
            public System.Byte __GSInterfaces21;
            public System.Byte __GSInterfaces22;
            public System.Byte __GSInterfaces23;
            public System.Byte __GSInterfaces24;
            public System.Byte __GSInterfaces25;
            public System.Byte __GSInterfaces26;
            public System.Byte __GSInterfaces27;
            public System.Byte __GSInterfaces28;
            public System.Byte __GSInterfaces29;
            public System.Byte __GSInterfaces30;
            public System.Byte __GSInterfaces31;
            public System.Byte PixelShader;
            public System.Byte PSSamplers;
            public System.Byte __PSSamplers1;
            public System.Byte PSShaderResources;
            public System.Byte __PSShaderResources1;
            public System.Byte __PSShaderResources2;
            public System.Byte __PSShaderResources3;
            public System.Byte __PSShaderResources4;
            public System.Byte __PSShaderResources5;
            public System.Byte __PSShaderResources6;
            public System.Byte __PSShaderResources7;
            public System.Byte __PSShaderResources8;
            public System.Byte __PSShaderResources9;
            public System.Byte __PSShaderResources10;
            public System.Byte __PSShaderResources11;
            public System.Byte __PSShaderResources12;
            public System.Byte __PSShaderResources13;
            public System.Byte __PSShaderResources14;
            public System.Byte __PSShaderResources15;
            public System.Byte PSConstantBuffers;
            public System.Byte __PSConstantBuffers1;
            public System.Byte PSInterfaces;
            public System.Byte __PSInterfaces1;
            public System.Byte __PSInterfaces2;
            public System.Byte __PSInterfaces3;
            public System.Byte __PSInterfaces4;
            public System.Byte __PSInterfaces5;
            public System.Byte __PSInterfaces6;
            public System.Byte __PSInterfaces7;
            public System.Byte __PSInterfaces8;
            public System.Byte __PSInterfaces9;
            public System.Byte __PSInterfaces10;
            public System.Byte __PSInterfaces11;
            public System.Byte __PSInterfaces12;
            public System.Byte __PSInterfaces13;
            public System.Byte __PSInterfaces14;
            public System.Byte __PSInterfaces15;
            public System.Byte __PSInterfaces16;
            public System.Byte __PSInterfaces17;
            public System.Byte __PSInterfaces18;
            public System.Byte __PSInterfaces19;
            public System.Byte __PSInterfaces20;
            public System.Byte __PSInterfaces21;
            public System.Byte __PSInterfaces22;
            public System.Byte __PSInterfaces23;
            public System.Byte __PSInterfaces24;
            public System.Byte __PSInterfaces25;
            public System.Byte __PSInterfaces26;
            public System.Byte __PSInterfaces27;
            public System.Byte __PSInterfaces28;
            public System.Byte __PSInterfaces29;
            public System.Byte __PSInterfaces30;
            public System.Byte __PSInterfaces31;
            public System.Byte PSUnorderedAccessViews;
            public System.Byte ComputeShader;
            public System.Byte CSSamplers;
            public System.Byte __CSSamplers1;
            public System.Byte CSShaderResources;
            public System.Byte __CSShaderResources1;
            public System.Byte __CSShaderResources2;
            public System.Byte __CSShaderResources3;
            public System.Byte __CSShaderResources4;
            public System.Byte __CSShaderResources5;
            public System.Byte __CSShaderResources6;
            public System.Byte __CSShaderResources7;
            public System.Byte __CSShaderResources8;
            public System.Byte __CSShaderResources9;
            public System.Byte __CSShaderResources10;
            public System.Byte __CSShaderResources11;
            public System.Byte __CSShaderResources12;
            public System.Byte __CSShaderResources13;
            public System.Byte __CSShaderResources14;
            public System.Byte __CSShaderResources15;
            public System.Byte CSConstantBuffers;
            public System.Byte __CSConstantBuffers1;
            public System.Byte CSInterfaces;
            public System.Byte __CSInterfaces1;
            public System.Byte __CSInterfaces2;
            public System.Byte __CSInterfaces3;
            public System.Byte __CSInterfaces4;
            public System.Byte __CSInterfaces5;
            public System.Byte __CSInterfaces6;
            public System.Byte __CSInterfaces7;
            public System.Byte __CSInterfaces8;
            public System.Byte __CSInterfaces9;
            public System.Byte __CSInterfaces10;
            public System.Byte __CSInterfaces11;
            public System.Byte __CSInterfaces12;
            public System.Byte __CSInterfaces13;
            public System.Byte __CSInterfaces14;
            public System.Byte __CSInterfaces15;
            public System.Byte __CSInterfaces16;
            public System.Byte __CSInterfaces17;
            public System.Byte __CSInterfaces18;
            public System.Byte __CSInterfaces19;
            public System.Byte __CSInterfaces20;
            public System.Byte __CSInterfaces21;
            public System.Byte __CSInterfaces22;
            public System.Byte __CSInterfaces23;
            public System.Byte __CSInterfaces24;
            public System.Byte __CSInterfaces25;
            public System.Byte __CSInterfaces26;
            public System.Byte __CSInterfaces27;
            public System.Byte __CSInterfaces28;
            public System.Byte __CSInterfaces29;
            public System.Byte __CSInterfaces30;
            public System.Byte __CSInterfaces31;
            public System.Byte CSUnorderedAccessViews;
            public System.Byte IAVertexBuffers;
            public System.Byte __IAVertexBuffers1;
            public System.Byte __IAVertexBuffers2;
            public System.Byte __IAVertexBuffers3;
            public System.Byte IAIndexBuffer;
            public System.Byte IAInputLayout;
            public System.Byte IAPrimitiveTopology;
            public System.Byte OMRenderTargets;
            public System.Byte OMDepthStencilState;
            public System.Byte OMBlendState;
            public System.Byte RSViewports;
            public System.Byte RSScissorRects;
            public System.Byte RSRasterizerState;
            public System.Byte SOBuffers;
            public System.Byte Predication;
        }

        internal unsafe void __MarshalFree(ref __Native @ref)
        {
        }

        internal unsafe void __MarshalFrom(ref __Native @ref)
        {
            VertexShader = @ref.VertexShader;
            fixed (void *__to = &VSSamplers[0], __from = &@ref.VSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &VSShaderResources[0], __from = &@ref.VSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__to = &VSConstantBuffers[0], __from = &@ref.VSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &VSInterfaces[0], __from = &@ref.VSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            HullShader = @ref.HullShader;
            fixed (void *__to = &HSSamplers[0], __from = &@ref.HSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &HSShaderResources[0], __from = &@ref.HSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__to = &HSConstantBuffers[0], __from = &@ref.HSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &HSInterfaces[0], __from = &@ref.HSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            DomainShader = @ref.DomainShader;
            fixed (void *__to = &DSSamplers[0], __from = &@ref.DSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &DSShaderResources[0], __from = &@ref.DSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__to = &DSConstantBuffers[0], __from = &@ref.DSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &DSInterfaces[0], __from = &@ref.DSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            GeometryShader = @ref.GeometryShader;
            fixed (void *__to = &GSSamplers[0], __from = &@ref.GSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &GSShaderResources[0], __from = &@ref.GSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__to = &GSConstantBuffers[0], __from = &@ref.GSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &GSInterfaces[0], __from = &@ref.GSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            PixelShader = @ref.PixelShader;
            fixed (void *__to = &PSSamplers[0], __from = &@ref.PSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &PSShaderResources[0], __from = &@ref.PSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__to = &PSConstantBuffers[0], __from = &@ref.PSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &PSInterfaces[0], __from = &@ref.PSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            PSUnorderedAccessViews = @ref.PSUnorderedAccessViews;
            ComputeShader = @ref.ComputeShader;
            fixed (void *__to = &CSSamplers[0], __from = &@ref.CSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &CSShaderResources[0], __from = &@ref.CSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__to = &CSConstantBuffers[0], __from = &@ref.CSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__to = &CSInterfaces[0], __from = &@ref.CSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            CSUnorderedAccessViews = @ref.CSUnorderedAccessViews;
            fixed (void *__to = &IAVertexBuffers[0], __from = &@ref.IAVertexBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
            IAIndexBuffer = @ref.IAIndexBuffer;
            IAInputLayout = @ref.IAInputLayout;
            IAPrimitiveTopology = @ref.IAPrimitiveTopology;
            OMRenderTargets = @ref.OMRenderTargets;
            OMDepthStencilState = @ref.OMDepthStencilState;
            OMBlendState = @ref.OMBlendState;
            RSViewports = @ref.RSViewports;
            RSScissorRects = @ref.RSScissorRects;
            RSRasterizerState = @ref.RSRasterizerState;
            SOBuffers = @ref.SOBuffers;
            Predication = @ref.Predication;
        }

        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.VertexShader = VertexShader;
            fixed (void *__from = &VSSamplers[0], __to = &@ref.VSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &VSShaderResources[0], __to = &@ref.VSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__from = &VSConstantBuffers[0], __to = &@ref.VSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &VSInterfaces[0], __to = &@ref.VSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            @ref.HullShader = HullShader;
            fixed (void *__from = &HSSamplers[0], __to = &@ref.HSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &HSShaderResources[0], __to = &@ref.HSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__from = &HSConstantBuffers[0], __to = &@ref.HSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &HSInterfaces[0], __to = &@ref.HSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            @ref.DomainShader = DomainShader;
            fixed (void *__from = &DSSamplers[0], __to = &@ref.DSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &DSShaderResources[0], __to = &@ref.DSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__from = &DSConstantBuffers[0], __to = &@ref.DSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &DSInterfaces[0], __to = &@ref.DSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            @ref.GeometryShader = GeometryShader;
            fixed (void *__from = &GSSamplers[0], __to = &@ref.GSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &GSShaderResources[0], __to = &@ref.GSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__from = &GSConstantBuffers[0], __to = &@ref.GSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &GSInterfaces[0], __to = &@ref.GSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            @ref.PixelShader = PixelShader;
            fixed (void *__from = &PSSamplers[0], __to = &@ref.PSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &PSShaderResources[0], __to = &@ref.PSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__from = &PSConstantBuffers[0], __to = &@ref.PSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &PSInterfaces[0], __to = &@ref.PSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            @ref.PSUnorderedAccessViews = PSUnorderedAccessViews;
            @ref.ComputeShader = ComputeShader;
            fixed (void *__from = &CSSamplers[0], __to = &@ref.CSSamplers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &CSShaderResources[0], __to = &@ref.CSShaderResources)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 16 * sizeof (System.Byte));
            fixed (void *__from = &CSConstantBuffers[0], __to = &@ref.CSConstantBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 2 * sizeof (System.Byte));
            fixed (void *__from = &CSInterfaces[0], __to = &@ref.CSInterfaces)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 32 * sizeof (System.Byte));
            @ref.CSUnorderedAccessViews = CSUnorderedAccessViews;
            fixed (void *__from = &IAVertexBuffers[0], __to = &@ref.IAVertexBuffers)
                SharpDX.Utilities.CopyMemory((System.IntPtr)__to, (System.IntPtr)__from, 4 * sizeof (System.Byte));
            @ref.IAIndexBuffer = IAIndexBuffer;
            @ref.IAInputLayout = IAInputLayout;
            @ref.IAPrimitiveTopology = IAPrimitiveTopology;
            @ref.OMRenderTargets = OMRenderTargets;
            @ref.OMDepthStencilState = OMDepthStencilState;
            @ref.OMBlendState = OMBlendState;
            @ref.RSViewports = RSViewports;
            @ref.RSScissorRects = RSScissorRects;
            @ref.RSRasterizerState = RSRasterizerState;
            @ref.SOBuffers = SOBuffers;
            @ref.Predication = Predication;
        }
    }
}